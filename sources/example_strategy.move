module example_strategy::example_strategy {

    use std::signer;
    use aptos_framework::account::{Self, SignerCapability};
    use aptos_framework::fungible_asset::{Self, FungibleAsset, FungibleStore, Metadata};
    use aptos_framework::object::Object;
    use aptos_framework::primary_fungible_store;

    use satay::strategy::{Self, BaseStrategy};
    use satay::vault::Vault;

    struct StrategyWitness has drop {}

    struct StrategyCapability has key {
        strategy_cap: SignerCapability,
    }

    // The strategy struct stores the vault and the base strategy
    // it could also be used to store other strategy info or config like the yield source addresses etc
    struct ExampleStrategy has key {
        vault: Object<Vault>,
        base_strategy: Object<BaseStrategy>,
    }

    const SEED_STRATEGY: vector<u8> = b"example_strategy";

    // Initialize the strategy with the vault and the base asset
    public entry fun initialize(
        manager: &signer,
        vault: Object<Vault>,
        asset: Object<Metadata>
    ) {
        assert!(!exists<ExampleStrategy>(signer::address_of(manager)), 0);

        let (strategy_signer, strategy_cap) = account::create_resource_account(manager, SEED_STRATEGY);
        let base_strategy = strategy::create<StrategyWitness>(asset, StrategyWitness {});

        let cap = StrategyCapability { strategy_cap };
        let example_strategy = ExampleStrategy { vault, base_strategy };

        move_to(&strategy_signer, cap);
        move_to(&strategy_signer, example_strategy);
    }

    // Deposit the base asset into the vault and issue the shares to the signer.
    public entry fun deposit(
        account: &signer,
        amount: u64
    ) acquires ExampleStrategy {
        let strategy_address = strategy_address();
        let strategy = borrow_global<ExampleStrategy>(strategy_address);
        let account_address = signer::address_of(account);
        let user_store = primary_fungible_store::ensure_primary_store_exists(
            account_address,
            strategy::base_metadata(strategy.base_strategy)
        );

        let base_asset = deposit_(account, user_store, amount);
        primary_fungible_store::deposit(account_address, base_asset);
    }

    public fun deposit_(
        account: &signer,
        store: Object<FungibleStore>,
        amount: u64
    ): FungibleAsset acquires ExampleStrategy {
        let strategy_address = strategy_address();
        let strategy = borrow_global<ExampleStrategy>(strategy_address);

        let base_asset = fungible_asset::withdraw(account, store, amount);
        let shares_asset = strategy::issue(strategy.base_strategy, &base_asset, &StrategyWitness {});

        deploy_to_yield_source(base_asset);

        shares_asset
    }

    // Withdraw the base asset by redeeming the strategy shares
    public fun withdraw(
        account: &signer,
        amount: u64
    ) acquires ExampleStrategy {
        let strategy_address = strategy_address();
        let strategy = borrow_global<ExampleStrategy>(strategy_address);
        let account_address = signer::address_of(account);
        let store = primary_fungible_store::ensure_primary_store_exists(
            account_address,
            strategy::shares_metadata(strategy.base_strategy)
        );

        let asset = withdraw_internal(account, store, amount);
        fungible_asset::deposit(store, asset);
    }

    fun withdraw_internal(
        account: &signer,
        store: Object<FungibleStore>,
        amount: u64
    ): FungibleAsset acquires ExampleStrategy {
        let strategy_address = strategy_address();
        let strategy = borrow_global<ExampleStrategy>(strategy_address);
        assert!(
            fungible_asset::store_metadata(store) == strategy::shares_metadata(strategy.base_strategy),
            0
        );

        let shares_asset = fungible_asset::withdraw(account, store, amount);
        let withdraw_amount = strategy::redeem(strategy.base_strategy, shares_asset, &StrategyWitness {});

        if (!has_sufficient_funds(strategy, withdraw_amount)) {
            return withdraw_from_yield_source(withdraw_amount, strategy);
        };

        fungible_asset::zero(strategy::shares_metadata(strategy.base_strategy))
    }

    // Harvest the yield generated by the strategy, convert it into shares, and reinvest it back into the strategy
    public entry fun harvest(
        manager: &signer
    ) acquires ExampleStrategy {
        let strategy_address = strategy_address();
        let strategy = borrow_global<ExampleStrategy>(strategy_address);

        // Only the manager or authorized account should be able to harvest
        let manager_address = signer::address_of(manager);
        assert!(is_authorized_manager(manager_address, strategy_address), 0);

        // Collect yield from the deployed assets
        let yield_asset = collect_yield(strategy);

        // Convert the yield into the base asset if necessary
        let base_asset = convert_yield_to_base(yield_asset);

        // Reinvest the base asset into the strategy to generate more yield
        reinvest(base_asset, strategy);
    }

    public fun vault(): Object<Vault> acquires ExampleStrategy {
        let strategy = borrow_global<ExampleStrategy>(strategy_address());
        strategy.vault
    }

    public fun name(): vector<u8> {
        b"Example Strategy"
    }

    public fun version(): vector<u8> {
        b"0.0.3"
    }

    fun deploy_to_yield_source(asset: FungibleAsset) {
        // Implement the logic to deploy the asset into a yield-generating source
        abort 0
    }

    fun has_sufficient_funds(strategy: &ExampleStrategy, amount: u64): bool {
        // Implement logic to check if the strategy has sufficient funds to cover the withdrawal
        false
    }

    fun withdraw_from_yield_source(amount: u64, strategy: &ExampleStrategy): FungibleAsset {
        // Implement logic to withdraw assets from the yield source
        fungible_asset::zero(strategy::shares_metadata(strategy.base_strategy))
    }

    fun collect_yield(strategy: &ExampleStrategy): FungibleAsset {
        // Implement the logic to collect yield from the deployed assets
        fungible_asset::zero(strategy::shares_metadata(strategy.base_strategy))
    }

    fun convert_yield_to_base(yield_asset: FungibleAsset): FungibleAsset {
        // Implement the logic to convert the yield into the base asset
        yield_asset
    }

    fun reinvest(base_asset: FungibleAsset, strategy: &ExampleStrategy) {
        // Implement the logic to reinvest the base asset back into the strategy
        deploy_to_yield_source(base_asset);
    }

    fun is_authorized_manager(manager_address: address, strategy_address: address): bool {
        // Implement logic to check if the caller is an authorized manager for the strategy
        true
    }

    fun strategy_address(): address {
        // @example_strategy would be replaced with the actual address of the manager or something else in a real implementation
        account::create_resource_address(&@example_strategy, SEED_STRATEGY)
    }

    fun strategy_signer(): signer acquires StrategyCapability {
        account::create_signer_with_capability(&borrow_global<StrategyCapability>(strategy_address()).strategy_cap)
    }
}
